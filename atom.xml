<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Apocalyptic&#39;s Blog</title>
  
  <subtitle>&lt;font color=green&gt;Time is over!&lt;/font&gt;</subtitle>
  <link href="http://apocalyptic0.github.io/atom.xml" rel="self"/>
  
  <link href="http://apocalyptic0.github.io/"/>
  <updated>2022-06-07T08:42:12.439Z</updated>
  <id>http://apocalyptic0.github.io/</id>
  
  <author>
    <name>Apocalyptic!</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP note</title>
    <link href="http://apocalyptic0.github.io/2022/06/07/Http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://apocalyptic0.github.io/2022/06/07/Http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-06T16:00:00.000Z</published>
    <updated>2022-06-07T08:42:12.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http权威指南学习笔记"><a href="#Http权威指南学习笔记" class="headerlink" title="Http权威指南学习笔记"></a>Http权威指南学习笔记</h1><p>本篇笔记采用Q&amp;A形式，因为该部分对笔者是全新的领域，希望能以此对该部分又更深的了解</p><span id="more"></span><h1 id="第1章-HTTP概述"><a href="#第1章-HTTP概述" class="headerlink" title="第1章 HTTP概述"></a>第1章 HTTP概述</h1><p>Q:Web客户端与服务器是如何通信的；<br>Q:（表示Web内容的）资源来自何方；<br>Q:Web事务是怎样工作的；<br>Q:HTTP通信所使用的报文格式；<br>Q:底层TCP网络运输；<br>Q:不同的HTTP协议变体；<br>Q:因特网上安装的大量HTTP架构组件中的一部分；</p><h2 id="1-1-HTTP————因特网的多媒体形式"><a href="#1-1-HTTP————因特网的多媒体形式" class="headerlink" title="1.1 HTTP————因特网的多媒体形式"></a>1.1 HTTP————因特网的多媒体形式</h2><p>Q:HTTP是什么；<br>A:HTTP是现代全球因特网中使用的公共语言；</p><p>Q:HTTP满足因特网传输需求的条件或者说它的特点；<br>A:使用可靠的数据传输协议，保证数据在传输时不会损坏或混乱，HTTP通信也不会再传输过程中破坏。这对用户和开发人员都相当便利；</p><h2 id="1-2-Web客户端和服务器"><a href="#1-2-Web客户端和服务器" class="headerlink" title="1.2 Web客户端和服务器"></a>1.2 Web客户端和服务器</h2><p>Q:什么是客户端和服务器；<br>A:Web内容存储在Web服务器上，服务器使用HTTP协议，常称为HTTP服务器。<br>客户端就是呈现在用户面前的网页，软件等；</p><p>Q:有什么区别和联系；<br>A:客户端向服务器发出请求，服务器提供所请求的数据，即HTTP请求和HTTP响应，HTTP客户端和HTTP服务器共同构成了万维网基本组件。</p><h2 id="1-3-资源"><a href="#1-3-资源" class="headerlink" title="1.3 资源"></a>1.3 资源</h2><p>Q:什么是Web资源；<br>A:Web服务器是Web资源的宿主，Web资源是Web内容的源头；<br>所有能提供Web内容的东西就是Web资源</p><p>Q:Web资源包括；<br>A:最简单的Web资源：Web服务器文件系统的静态文件。可以包含任意内容和格式；<br>资源还可以是根据需要生成内容的软件程序，即动态资源；</p><h3 id="1-3-1-媒体类型"><a href="#1-3-1-媒体类型" class="headerlink" title="1.3.1 媒体类型"></a>1.3.1 媒体类型</h3><p>Q:什么是MIME类型；<br>A:Multipurpose Internet Mail Extension，多用途因特网邮件扩展；</p><p>Q:为什么要设计MIME；<br>A:为了解决在不同的电子邮件系统之间搬移报文时存在的问题</p><p>Q:Web如何处理MIME；<br>A:Web服务器会为所用HTTP对象附加一个MIME类型，当Web浏览器（客户端）从服务器中取回一个对象时，回去查看相关的MIME，看看它是否知道应该如何处理该对象。大多数浏览器可以处理数百种常见的对象类型；</p><p>Q:MIME格式；<br>A:MIME类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由斜杠分隔。如：<br>HTML:text&#x2F;html   ASCII:text&#x2F;plain   JEPG:image&#x2F;jpeg<br>你可以在附录D找到完整的MIME类型表；</p><h3 id="1-3-2-URI"><a href="#1-3-2-URI" class="headerlink" title="1.3.2 URI"></a>1.3.2 URI</h3><p>Q:什么是URI；<br>A:Uniform Resource Identifier，URI 统一资源标识符，是服务器资源名，在世界范围内唯一标识并定位信息资源。给定URI，HTTP就能解析出对象。URI分为URL和URN；</p><h3 id="1-3-3-URL"><a href="#1-3-3-URL" class="headerlink" title="1.3.3 URL"></a>1.3.3 URL</h3><p>Q:什么是URL；<br>A:统一资源定位符，是资源标识符最常见的形式。URL描述了一台特定服务器上资源的特定位置。</p><p>Q:URL标准格式是怎么样的；<br>A:三部分</p><ol><li>scheme 方案，说明了访问资源所使用的协议类型，通常就是HTTP协议（http:&#x2F;&#x2F;）；</li><li>服务器的因特网地址（<a href="http://www.hust.unique.com)即主机位于何处/">www.hust.unique.com）即主机位于何处</a></li><li>其余部分指定了Web服务器上的某个资源(&#x2F;spacials&#x2F;saw-blade.gif)；</li></ol><h3 id="1-3-4-URN"><a href="#1-3-4-URN" class="headerlink" title="1.3.4 URN"></a>1.3.4 URN</h3><p>Q:什么是URN；<br>A:统一资源名。作为特定内容的唯一名称使用，与资源所在地无关，使用它们可以将资源四处搬运。还可以用同一个名字通过多种网络访问协议来访问资源。</p><p>Q:为什么URN未大范围使用<br>A:URN仍然处于试验阶段，还未大范围使用。URN需要一个支撑架构来解析资源的位置，此类架构的缺乏延缓了其被采用的进度。<font color="red">未来可期</font></p><h2 id="1-4-事务"><a href="#1-4-事务" class="headerlink" title="1.4 事务"></a>1.4 事务</h2><p>Q:一个事务是怎么进行的；<br>A:一个事务由一条请求命令和一个响应结果组成。通过名为HTTP报文(HTTP message)的格式化数据块进行；</p><h3 id="1-4-1-方法"><a href="#1-4-1-方法" class="headerlink" title="1.4.1 方法"></a>1.4.1 方法</h3><p>Q:什么是HTTP方法；<br>A:HTTP支持几种不同的请求命令，这些命令就是方法，每条请求报文都包含一个方法，告诉服务器要执行什么动作<br>表 一些常见的HTTP方法；</p><table><thead><tr><th>HTTP方法</th><th></th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td></td><td>从服务器向客户端发送命令资源</td></tr><tr><td>PUT</td><td></td><td>将来自客户端的数据存储到一个命名的服务器资源中去</td></tr><tr><td>DELETE</td><td></td><td>从服务器中删除命名资源</td></tr><tr><td>POST</td><td></td><td>将客户端数据发送到一个服务器网关应用程序</td></tr><tr><td>HEAD</td><td></td><td>仅发送命名资源响应中的HTTP首部</td></tr></tbody></table><h3 id="1-4-2-状态码"><a href="#1-4-2-状态码" class="headerlink" title="1.4.2 状态码"></a>1.4.2 状态码</h3><p>Q:什么是状态码；<br>A:每条HTTP响应报文返回时都会携带一个状态码，是一个三位数的代码，告知客户端请求是否成功，或者是否需要采取其他动作；<br>表 一些常见HTTP状态码</p><table><thead><tr><th>HTTP状态码</th><th></th><th>描述</th></tr></thead><tbody><tr><td>200</td><td></td><td>OK,文档正确返回</td></tr><tr><td>302</td><td></td><td>Redirect(重定向)到其他地方去获取资源</td></tr><tr><td>404</td><td></td><td>Not Found(没找到)无法找到这个资源</td></tr></tbody></table><h3 id="1-4-3-Web页面中可以包含多个对象"><a href="#1-4-3-Web页面中可以包含多个对象" class="headerlink" title="1.4.3 Web页面中可以包含多个对象"></a>1.4.3 Web页面中可以包含多个对象</h3><p>Q:浏览器如何包含多个资源；<br>A:浏览器会执行一个事务来获取描述页面布局的HTML框架，然后发布另外的HTTP事务来获取其他资源</p><h2 id="1-5-报文"><a href="#1-5-报文" class="headerlink" title="1.5 报文"></a>1.5 报文</h2><p>Q:HTTP报文有什么特点；<br>A:是一行一行的简单字符串组成的，是纯文本，不是二进制。可以方便的读写，有可扩展性和可调式性</p><p>Q:HTTP报文的结构；<br>A:三个部分</p><ol><li>起始行 报文的第一行，在请求报文中说明要做什么，在响应报文中说明出现了什么情况</li><li>首部字段 起始行后面有0个或多个首部字段。每个首部字段包含一个名字和一个值，用冒号分隔。以一个空行结束。</li><li>主体 包含了所有类型的数据。主体可以包含任意的二进制数据，也可以包含文本。</li></ol><h2 id="1-6-链接"><a href="#1-6-链接" class="headerlink" title="1.6 链接"></a>1.6 链接</h2><h3 id="1-6-1-TCP-x2F-IP"><a href="#1-6-1-TCP-x2F-IP" class="headerlink" title="1.6.1 TCP&#x2F;IP"></a>1.6.1 TCP&#x2F;IP</h3><p>Q:同是协议，HTTP和TCP&#x2F;IP有什么不同；<br>A:HTTP是应用层协议，它把联网的具体细节交给了通用可靠的因特网传输协议TCP&#x2F;IP；</p><p>Q:TCP是什么，有什么用；<br>A:TCP&#x2F;IP是全世界的计算机和网络设备常用的层次化分组交换网络协议集<br>隐藏了各种网络和硬件的特点及弱点，保证了可靠通信。<br>其提供了：</p><ul><li>无差错的数据传输</li><li>按序传输</li><li>未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）</li></ul><p>表：HTTP TCP IP的分层</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>HTTP</td><td></td><td>应用层</td></tr><tr><td>TCP</td><td></td><td>传输层</td></tr><tr><td>IP</td><td></td><td>网络层</td></tr><tr><td>网络特有的链路接口</td><td></td><td>数据链路层</td></tr><tr><td>物理网络硬件</td><td></td><td>物理层</td></tr></tbody></table><h3 id="1-6-2-链接、IP地址及端口号"><a href="#1-6-2-链接、IP地址及端口号" class="headerlink" title="1.6.2 链接、IP地址及端口号"></a>1.6.2 链接、IP地址及端口号</h3><p>Q:三者联系；<br>A:使用IP地址和TCP端口号建立链接，IP地址和端口号通过URL获取；</p><p>Q:如何获取；<br>A:</p><ol><li>URL直接使用IP地址<br>如：<a href="http://207.200.83.29/idex.html">http://207.200.83.29:80/idex.html</a> IP地址207.200.83.29及端口号80；</li><li>没有使用数字形式的IP地址，使用文本形式的域名，或者称为主机名，可以通过DNS（域名服务）的机制转换</li><li>没有端口号时，默认为80</li></ol><h3 id="1-6-3-使用Telnet实例"><a href="#1-6-3-使用Telnet实例" class="headerlink" title="1.6.3 使用Telnet实例"></a>1.6.3 使用Telnet实例</h3><p>Q:Telnet的作用；<br>A:直接与Web客户端交互和对话。将TCP端口的输出会送到显示屏上</p><p>Q:如何开启Telnet<br>A:Win10：右键开始-&gt;应用和功能-&gt;程序和功能-&gt;打开或关闭Windows功能-&gt;Telnet客户端</p><h2 id="1-7-协议版本"><a href="#1-7-协议版本" class="headerlink" title="1.7 协议版本"></a>1.7 协议版本</h2><h2 id="1-8-Web的结构组件"><a href="#1-8-Web的结构组件" class="headerlink" title="1.8 Web的结构组件"></a>1.8 Web的结构组件</h2><p>Q:重要的应用程序<br>A:</p><ul><li>代理<br>位于客户端和服务器之间的HTTP中间实体</li><li>缓存<br>HTTP的仓库，使常用页面的副本可以保持在离客户端更近的地方</li><li>网关<br>连接其他应用程序的特殊Web服务器</li><li>隧道<br>对HTTP通信报文进行盲转发的特殊代理</li><li>Agent代理<br>发起自动HTTP请求的半智能Web客户端</li></ul><h3 id="1-8-1-代理"><a href="#1-8-1-代理" class="headerlink" title="1.8.1 代理"></a>1.8.1 代理</h3><p>对用户而言，应用程序就是一个代理<br>代理位于客户端和服务器中间，接受并转发请求<br>详细介绍在第6章</p><h3 id="1-8-2-缓存"><a href="#1-8-2-缓存" class="headerlink" title="1.8.2 缓存"></a>1.8.2 缓存</h3><p>缓存使调用更高效，在不同用户请求同一文档时提供便利<br>详细介绍在第7章</p><h3 id="1-8-3-网关"><a href="#1-8-3-网关" class="headerlink" title="1.8.3 网关"></a>1.8.3 网关</h3><p>网关(gateway)在服务器之间转换协议<br>详细介绍在第8章</p><h3 id="1-8-4-隧道"><a href="#1-8-4-隧道" class="headerlink" title="1.8.4 隧道"></a>1.8.4 隧道</h3><p>隧道可以用于在HTTP连接上转发非HTTP数据，也可以用于非HTTP上网络转发数据</p><h3 id="1-8-5-Agent代理"><a href="#1-8-5-Agent代理" class="headerlink" title="1.8.5 Agent代理"></a>1.8.5 Agent代理</h3><p>代表用户发起HTTP请求的客户端程序，如Web浏览器<br>还有些自己在Web上闲逛的Agent代理，在无人监视的情况下获取内容</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>待补充</p><h1 id="URL与资源"><a href="#URL与资源" class="headerlink" title="URL与资源"></a>URL与资源</h1><h2 id="2-1-浏览因特网资源"><a href="#2-1-浏览因特网资源" class="headerlink" title="2.1 浏览因特网资源"></a>2.1 浏览因特网资源</h2><p>Q:URL只能通过HTTP访问资源吗<br>A:不是，也可以通过其他协议，比如文件传输协议FTP或者下载电影RTSP</p><p>Q:URL带来的便利<br>A:URL告知了浏览器如何对资源进行访问和处理，为用户和浏览器提供了找到信息所需的所有条件。也就是说，它不仅仅提供location，还帮助用户进行获取的一系列操作</p><h2 id="2-2-URL的语法"><a href="#2-2-URL的语法" class="headerlink" title="2.2 URL的语法"></a>2.2 URL的语法</h2><p>大部分URL方案语法的通用格式<br><scheme>:&#x2F;&#x2F;<user>:<password>@<host>:<port>&#x2F;<path></path>;<params>?<query>#<frag><br>事实上，几乎没有哪个URL能包含所有这些组件。<br>最重要的三个部分是方案，主机和路径，即scheme host path</frag></query></params></port></host></password></user></scheme></p><p>通用URL组件</p><table><thead><tr><th>组件</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>方案</td><td>使用的协议，大小写无关</td><td>无</td></tr><tr><td>用户</td><td>某些方案(如FTP)访问资源时需要用户名</td><td>匿名(anonymous)</td></tr><tr><td>密码</td><td>用户名后可能包含的密码，中间用:分隔</td><td>&lt;E-mail地址&gt;</td></tr><tr><td>主机</td><td>资源宿主的主机名或IP地址</td><td>无</td></tr><tr><td>端口</td><td>资源宿主服务器正在监听的端口号，很多方案有默认，如HTTP的80</td><td>每个方案特有</td></tr><tr><td>路径</td><td>服务器上资源的本地名，由斜杠&#x2F;分隔，语法与服务器和方案有关</td><td>无</td></tr><tr><td>参数</td><td>参数为名&#x2F;值对，以分号;分隔</td><td>无</td></tr><tr><td>查询</td><td>传递参数以激活应用程序，没有通用格式，用?开始一边以&amp;分隔</td><td>无</td></tr><tr><td>片段</td><td>一部分资源的名字，在客户端内部使用，不传给服务器，用#分隔</td><td>无</td></tr></tbody></table><ul><li>需要用户名访问时会提供一个默认的匿名和相应的密码</li><li>路径组件可以分为若干路径段，每个路径段都可以有自己的参数</li><li>参数表示，如type&#x3D;d;sale&#x3D;false</li><li>query组件用于缩小请求资源类型范围，查询组件和URL路径组件一起发送给网关，基本上可以把网关当做访问其他应用程序的访问点，示例：<br>item&#x3D;121731&amp;color&#x3D;blue&amp;size&#x3D;large</li><li>HTTP服务器通常只处理整个对象，而不是对象的片段，客户端不能将片段传给服务器</li></ul><h2 id="2-3-URL快捷方式"><a href="#2-3-URL快捷方式" class="headerlink" title="2.3 URL快捷方式"></a>2.3 URL快捷方式</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Http权威指南学习笔记&quot;&gt;&lt;a href=&quot;#Http权威指南学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Http权威指南学习笔记&quot;&gt;&lt;/a&gt;Http权威指南学习笔记&lt;/h1&gt;&lt;p&gt;本篇笔记采用Q&amp;amp;A形式，因为该部分对笔者是全新的领域，希望能以此对该部分又更深的了解&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="http://apocalyptic0.github.io/categories/notes/"/>
    
    
    <category term="HTTP,Web" scheme="http://apocalyptic0.github.io/tags/HTTP-Web/"/>
    
  </entry>
  
  <entry>
    <title>Computer Graphics notes</title>
    <link href="http://apocalyptic0.github.io/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://apocalyptic0.github.io/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2022-05-01T16:00:00.000Z</published>
    <updated>2022-06-07T08:37:54.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学学习记录"><a href="#计算机图形学学习记录" class="headerlink" title="计算机图形学学习记录"></a>计算机图形学学习记录</h1><h2 id="Bresenham画线算法"><a href="#Bresenham画线算法" class="headerlink" title="Bresenham画线算法"></a>Bresenham画线算法</h2><p>首先编写一个画线的简单算法：</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(<span class="type">int</span> x0,<span class="type">int</span> y0,<span class="type">int</span> x1,<span class="type">int</span> y1,TGAImage &amp;image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">float</span> t=<span class="number">0.</span>;t&lt;<span class="number">1.</span>;t+=<span class="number">.01</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> x=x0+(x1-x0)*t;</span><br><span class="line">       <span class="type">int</span> y=y0+(y1-y0)*t;</span><br><span class="line">       image.<span class="built_in">set</span>(x,y,color);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>t的变化决定采样的数量，当t变为.1时，线段会变成连续的点<br>该方法将线段均分，找到每一部分的点设置颜色，但每个点的数据都是浮点型，效率不高。<br>一种简单的修改方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(<span class="type">int</span> x0,<span class="type">int</span> y0,<span class="type">int</span> x1,<span class="type">int</span> y1,TGAImage &amp;image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=x0;x&lt;=x1;x++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">float</span> t=(x-x0)/(<span class="type">float</span>)(x1-x0);</span><br><span class="line">       <span class="type">int</span> y=y0*(<span class="number">1.</span>-t)+y1*t;</span><br><span class="line">       image.<span class="built_in">set</span>(x,y,color);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，起码坐标的一半（x）是整数了，但这种方法是错误的</p><ul><li>必须满足x1&gt;x0,但实际上我们希望决定直线的两个点顺序和直线不相关</li><li>当直线比较陡时（k比较大时），对x采样会比较少，直线不连续<br>如：<br>line(20,13,40,80,image,red);<br>line(80,40,13,20,image,red);<br>前者输出连续的点，后者无图像</li></ul><p>首先解决交换点的问题，我们通过交换点使x0始终小于x1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(<span class="type">int</span> x0,<span class="type">int</span> y0,<span class="type">int</span> x1,<span class="type">int</span> y1,TGAImage &amp;image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">bool</span> steep=<span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span>(std::<span class="built_in">abs</span>(x0-x1)&lt;std::<span class="built_in">abs</span>(y0-y1))&#123;</span><br><span class="line">       <span class="comment">//如果直线是陡的，交换xy，对y进行采样(但最后的坐标还是以xy输出)</span></span><br><span class="line">       std::<span class="built_in">swap</span>(x0,y0);</span><br><span class="line">       std::<span class="built_in">swap</span>(x1,y1);</span><br><span class="line">       steep=<span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(x0&gt;x1)&#123;</span><br><span class="line">       <span class="comment">//如果x0&gt;x1，交换以保证x0小</span></span><br><span class="line">       std::<span class="built_in">swap</span>(x0,x1);</span><br><span class="line">       std::<span class="built_in">swap</span>(y0,y1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;=x1;x++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">float</span> t=(x-x0)/(<span class="type">float</span>)(x1-x0);</span><br><span class="line">       <span class="type">int</span> y=y0*(<span class="number">1.</span>-t)+y1*t;</span><br><span class="line">       <span class="keyword">if</span>(steep)&#123;</span><br><span class="line">           image.<span class="built_in">set</span>(y,x,color);<span class="comment">//如果之前交换了xy，现在作图时要交换回来</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           image.<span class="built_in">set</span>(x,y,color);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，该把y也变成整数了<br>开始使用Bresenham画线算法：</p><ul><li><a href="https://www.bilibili.com/read/cv10767706">参考文章</a></li><li>当直线分布在坐标格里时，我们对x逐渐加一时，通过y离上下整数点的距离确定y的值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(<span class="type">int</span> x0,<span class="type">int</span> y0,<span class="type">int</span> x1,<span class="type">int</span> y1,TGAImage &amp;image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">bool</span> steep=<span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span>(std::<span class="built_in">abs</span>(x0-x1)&lt;std::<span class="built_in">abs</span>(y0-y1))&#123;</span><br><span class="line">       <span class="comment">//如果直线是陡的，交换xy，对y进行采样(但最后的坐标还是以xy输出)</span></span><br><span class="line">       std::<span class="built_in">swap</span>(x0,y0);</span><br><span class="line">       std::<span class="built_in">swap</span>(x1,y1);</span><br><span class="line">       steep=<span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(x0&gt;x1)&#123;</span><br><span class="line">       <span class="comment">//如果x0&gt;x1，交换以保证x0小</span></span><br><span class="line">       std::<span class="built_in">swap</span>(x0,x1);</span><br><span class="line">       std::<span class="built_in">swap</span>(y0,y1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> dx=x1-x0;</span><br><span class="line">   <span class="type">int</span> dy=y1-y0;</span><br><span class="line">   <span class="type">float</span> derror=std::<span class="built_in">abs</span>(dy/<span class="built_in">float</span>(dx));<span class="comment">//x的值加1，对应y的值加上derror</span></span><br><span class="line">   <span class="type">float</span> error=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> y=y0;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=x0;x&lt;=x1;x++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(steep)&#123;</span><br><span class="line">           image.<span class="built_in">set</span>(y,x,color);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           image.<span class="built_in">set</span>(x,y,color);</span><br><span class="line">       &#125;</span><br><span class="line">       error+=derror;<span class="comment">//y的值从0开始计算</span></span><br><span class="line">       <span class="keyword">if</span>(error&gt;<span class="number">.5</span>)&#123;</span><br><span class="line">           y+=(y1&gt;y0?<span class="number">1</span>;<span class="number">-1</span>);</span><br><span class="line">           error-=<span class="number">1</span>;<span class="comment">//重新累计error，error每加1，y就加1</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果能再把浮点顶点去掉就更好了，我们让error2&#x3D;error<em>dx</em>2<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="type">bool</span> steep = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">abs</span>(x0-x1)&lt;std::<span class="built_in">abs</span>(y0-y1)) &#123; </span><br><span class="line">        std::<span class="built_in">swap</span>(x0, y0); </span><br><span class="line">        std::<span class="built_in">swap</span>(x1, y1); </span><br><span class="line">        steep = <span class="literal">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (x0&gt;x1) &#123; </span><br><span class="line">        std::<span class="built_in">swap</span>(x0, x1); </span><br><span class="line">        std::<span class="built_in">swap</span>(y0, y1); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> dx = x1-x0; </span><br><span class="line">    <span class="type">int</span> dy = y1-y0; </span><br><span class="line">    <span class="type">int</span> derror2 = std::<span class="built_in">abs</span>(dy)*<span class="number">2</span>; </span><br><span class="line">    <span class="type">int</span> error2 = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> y = y0; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x=x0; x&lt;=x1; x++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (steep) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(y, x, color); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(x, y, color); </span><br><span class="line">        &#125; </span><br><span class="line">        error2 += derror2; </span><br><span class="line">        <span class="keyword">if</span> (error2 &gt; dx) &#123; </span><br><span class="line">            y += (y1&gt;y0?<span class="number">1</span>:<span class="number">-1</span>); </span><br><span class="line">            error2 -= dx*<span class="number">2</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>实际上仅仅只是让整个y的计算比较过程乘了个2*dx，但免去了很多浮点对速率的影响</li></ul><p>在知道了line函数后，绘制一个三角形的边框就很简单了，只需要输入三个顶点坐标，两两连线即可<br>但填充三角形并不是那么容易</p><h2 id="填充三角形"><a href="#填充三角形" class="headerlink" title="填充三角形"></a>填充三角形</h2><p>在此之前，我们要用另一种方法绘制三角形</p><ul><li>通过y坐标给顶点排序</li><li>对左右两边的三角形同时光栅化</li><li>在左右边界点绘制一条水平的直线<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0,Vec2i t1,Vec2i t2,TGAImage &amp;image,TGAColor color)</span></span>&#123;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">if</span>(t0.y&gt;t1.y)std::<span class="built_in">swap</span>(t0,t1);</span><br><span class="line">    <span class="keyword">if</span>(t0.y&gt;t2.y)std::<span class="built_in">swap</span>(t0,t2);</span><br><span class="line">    <span class="keyword">if</span>(t1.y&gt;t2.y)std::<span class="built_in">swap</span>(t1,t2);</span><br><span class="line">    <span class="type">int</span> total_height=t2.y-t0.y;</span><br><span class="line">    <span class="comment">//先绘制底部部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=t0.y;y&lt;=t1.y;y++)&#123;</span><br><span class="line">        <span class="type">int</span> segment_height=t1.y-t0.y+<span class="number">1</span>;</span><br><span class="line">        <span class="type">float</span> alpha=(<span class="type">float</span>)(y-t0.y)/total_height;</span><br><span class="line">        <span class="type">float</span> beta=(<span class="type">float</span>)(y-t0.y)/segment_height;</span><br><span class="line">        Vec2i A=t0+(t2-t0)*alpha;</span><br><span class="line">        Vec2i B=t0+(t1-t0)*beta;</span><br><span class="line">        image.<span class="built_in">set</span>(A.x,y,red);</span><br><span class="line">        image.<span class="built_in">set</span>(B.x,y,green);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这里，我们没有理会xy的交换，得到了不连续的线段，但是在之后的填充中，如果我们用水平线链接相应的点对，空隙就会消失</li></ul><p>现在，完成整个工作吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0,Vec2i t1,Vec2i t2,TGAImage &amp;image,TGAColor color)</span></span>&#123;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">if</span>(t0.y&gt;t1.y)std::<span class="built_in">swap</span>(t0,t1);</span><br><span class="line">    <span class="keyword">if</span>(t0.y&gt;t2.y)std::<span class="built_in">swap</span>(t0,t2);</span><br><span class="line">    <span class="keyword">if</span>(t1.y&gt;t2.y)std::<span class="built_in">swap</span>(t1,t2);</span><br><span class="line">    <span class="type">int</span> total_height=t2.y-t0.y;</span><br><span class="line">    <span class="comment">//先绘制底部部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=t0.y;y&lt;=t1.y;y++)&#123;</span><br><span class="line">        <span class="type">int</span> segment_height=t1.y-t0.y+<span class="number">1</span>;</span><br><span class="line">        <span class="type">float</span> alpha=(<span class="type">float</span>)(y-t0.y)/total_height;</span><br><span class="line">        <span class="type">float</span> beta=(<span class="type">float</span>)(y-t0.y)/segment_height;</span><br><span class="line">        Vec2i A=t0+(t2-t0)*alpha;</span><br><span class="line">        Vec2i B=t0+(t1-t0)*beta;</span><br><span class="line">        <span class="keyword">if</span>(A.x&gt;B.x)std::<span class="built_in">swap</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=A.x;j&lt;B.x;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            image.<span class="built_in">set</span>(j,y,color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=t1.y;y&lt;=t2.y;y++)&#123;</span><br><span class="line">        <span class="type">int</span> segment_height=t2.y-t1.y+<span class="number">1</span>;</span><br><span class="line">        <span class="type">float</span> alpha=(<span class="type">float</span>)(y-t0.y)/total_height;</span><br><span class="line">        <span class="type">float</span> beta=(<span class="type">float</span>)(y-t1.y)/segment_height;</span><br><span class="line">        Vec2i A=t0+(t2-t0)*alpha;</span><br><span class="line">        Vec2i B=t1+(t2-t1)*beta;</span><br><span class="line">        <span class="keyword">if</span>(A.x&gt;B.x)std::<span class="built_in">swap</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=A.x;j&lt;B.x;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            image.<span class="built_in">set</span>(j,y,color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把重复的部分改一下：<br>用一个second_half判定是否过t1，不再从t0开始，而是直接计算距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (t0.y==t1.y &amp;&amp; t0.y==t2.y) <span class="keyword">return</span>; <span class="comment">// I dont care about degenerate triangles </span></span><br><span class="line">    <span class="comment">// sort the vertices, t0, t1, t2 lower−to−upper (bubblesort yay!) </span></span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t1.y) std::<span class="built_in">swap</span>(t0, t1); </span><br><span class="line">    <span class="keyword">if</span> (t0.y&gt;t2.y) std::<span class="built_in">swap</span>(t0, t2); </span><br><span class="line">    <span class="keyword">if</span> (t1.y&gt;t2.y) std::<span class="built_in">swap</span>(t1, t2); </span><br><span class="line">    <span class="type">int</span> total_height = t2.y-t0.y; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;total_height; i++) &#123; </span><br><span class="line">        <span class="type">bool</span> second_half = i&gt;t1.y-t0.y || t1.y==t0.y; </span><br><span class="line">        <span class="type">int</span> segment_height = second_half ? t2.y-t1.y : t1.y-t0.y; </span><br><span class="line">        <span class="type">float</span> alpha = (<span class="type">float</span>)i/total_height; </span><br><span class="line">        <span class="type">float</span> beta  = (<span class="type">float</span>)(i-(second_half ? t1.y-t0.y : <span class="number">0</span>))/segment_height; <span class="comment">// be careful: with above conditions no division by zero here </span></span><br><span class="line">        Vec2i A =               t0 + (t2-t0)*alpha; </span><br><span class="line">        Vec2i B = second_half ? t1 + (t2-t1)*beta : t0 + (t1-t0)*beta; </span><br><span class="line">        <span class="keyword">if</span> (A.x&gt;B.x) std::<span class="built_in">swap</span>(A, B); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=A.x; j&lt;=B.x; j++) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(j, t0.y+i, color); <span class="comment">// attention, due to int casts t0.y+i != A.y </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用包围盒来填充三角形，甚至更加方便和简洁</p><ul><li>比较三个顶点，找到包围盒</li><li>判定包围盒内的每一个点是否在三角形内，若在，则填充，不在则跳过</li><li>判定方法：三角形内任意一点可以用三点的不同权重来表示<br>P&#x3D;(1-u-v)A+uB+vC;<br>即uAB+vAC+PA&#x3D;0;<br>分别去AB,AC,PA的x和y组成三维向量叉乘得到[u,v,1];<br>u,v,1同时大于0时点在三角形内</li></ul><p>判定的函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">barycentric</span><span class="params">(Vec2i *pts, Vec2i P)</span> </span>&#123; </span><br><span class="line">    Vec3f u = <span class="built_in">cross</span>(<span class="built_in">Vec3f</span>(pts[<span class="number">2</span>][<span class="number">0</span>]-pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">1</span>][<span class="number">0</span>]-pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">0</span>][<span class="number">0</span>]-P[<span class="number">0</span>]), <span class="built_in">Vec3f</span>(pts[<span class="number">2</span>][<span class="number">1</span>]-pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">1</span>][<span class="number">1</span>]-pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">0</span>][<span class="number">1</span>]-P[<span class="number">1</span>]));</span><br><span class="line">    <span class="comment">/* `pts` and `P` has integer value as coordinates</span></span><br><span class="line"><span class="comment">       so `abs(u[2])` &lt; 1 means `u[2]` is 0, that means</span></span><br><span class="line"><span class="comment">       triangle is degenerate, in this case return something with negative coordinates */</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">abs</span>(u[<span class="number">2</span>])&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>顶点坐标都是整数，如果u[2]绝对值小于1，那u[2]就是0了，表明三角形不存在，返回一个不满足条件的值即可；</p><p>填充函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec2i *pts, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="function">Vec2i <span class="title">bboxmin</span><span class="params">(image.get_width()<span class="number">-1</span>,  image.get_height()<span class="number">-1</span>)</span></span>; </span><br><span class="line">    <span class="function">Vec2i <span class="title">bboxmax</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">    <span class="function">Vec2i <span class="title">clamp</span><span class="params">(image.get_width()<span class="number">-1</span>, image.get_height()<span class="number">-1</span>)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++) &#123; </span><br><span class="line">            bboxmin[j] = std::<span class="built_in">max</span>(<span class="number">0</span>,        std::<span class="built_in">min</span>(bboxmin[j], pts[i][j])); </span><br><span class="line">            bboxmax[j] = std::<span class="built_in">min</span>(clamp[j], std::<span class="built_in">max</span>(bboxmax[j], pts[i][j])); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    Vec2i P; </span><br><span class="line">    <span class="keyword">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123; </span><br><span class="line">        <span class="keyword">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123; </span><br><span class="line">            Vec3f bc_screen  = <span class="built_in">barycentric</span>(pts, P); </span><br><span class="line">            <span class="keyword">if</span> (bc_screen.x&lt;<span class="number">0</span> || bc_screen.y&lt;<span class="number">0</span> || bc_screen.z&lt;<span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">            image.<span class="built_in">set</span>(P.x, P.y, color); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意包围盒的处理，省去了屏幕外的部分，如果数据给定的点在屏幕外，则不参与计算，节省了计算时间</p><h2 id="背面裁剪和z-Buffer-深度缓存"><a href="#背面裁剪和z-Buffer-深度缓存" class="headerlink" title="背面裁剪和z-Buffer(深度缓存)"></a>背面裁剪和z-Buffer(深度缓存)</h2><p>在对摄像机观察的画面渲染时，会出现场景中物体相互遮挡的情况，我们可以从后到前考察，前面的面会挡住后面的面，可以使用画家算法：painter’s algorithm。这个伴随着较高的计算资源。因为每一次摄像机移动，我们都要对场景重新排序，而且是对动态场景，并且主要问题在于并非总是能确定正确的顺序。</p><h3 id="先尝试三角形的叠加遮挡吧"><a href="#先尝试三角形的叠加遮挡吧" class="headerlink" title="先尝试三角形的叠加遮挡吧"></a>先尝试三角形的叠加遮挡吧</h3><p>太难了，让我们再减小一维度，Y-buffer！<br>现在，我们的场景只由线段构成了<br>这太简单了，只需要line()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三条线在空间中</span></span><br><span class="line"><span class="built_in">line</span>(<span class="built_in">Vec2i</span>(<span class="number">20</span>, <span class="number">34</span>),   <span class="built_in">Vec2i</span>(<span class="number">744</span>, <span class="number">400</span>), scene, red);</span><br><span class="line"><span class="built_in">line</span>(<span class="built_in">Vec2i</span>(<span class="number">120</span>, <span class="number">434</span>), <span class="built_in">Vec2i</span>(<span class="number">444</span>, <span class="number">400</span>), scene, green);</span><br><span class="line"><span class="built_in">line</span>(<span class="built_in">Vec2i</span>(<span class="number">330</span>, <span class="number">463</span>), <span class="built_in">Vec2i</span>(<span class="number">594</span>, <span class="number">200</span>), scene, blue);</span><br><span class="line"><span class="comment">//和一个底面</span></span><br><span class="line"><span class="built_in">line</span>(<span class="built_in">Vec2i</span>(<span class="number">10</span>, <span class="number">10</span>), <span class="built_in">Vec2i</span>(<span class="number">790</span>, <span class="number">10</span>), scene, white);</span><br></pre></td></tr></table></figure><p>现在让我们来渲染它，我们最后会得到一条线，长为width，高为16(方便在屏幕上查看)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TGAImage <span class="title">render</span><span class="params">(width, <span class="number">16</span>, TGAImage::RGB)</span></span>;</span><br><span class="line"><span class="type">int</span> ybuffer[width];<span class="comment">//记录每一点的高度，越高的(值越大的)应该在前面</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">    ybuffer[i]=std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();<span class="comment">//初始化为负无穷</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rasterize</span>(<span class="built_in">Vec2i</span>(<span class="number">20</span>, <span class="number">34</span>),   <span class="built_in">Vec2i</span>(<span class="number">744</span>, <span class="number">400</span>), render, red,   ybuffer);</span><br><span class="line"><span class="built_in">rasterize</span>(<span class="built_in">Vec2i</span>(<span class="number">120</span>, <span class="number">434</span>), <span class="built_in">Vec2i</span>(<span class="number">444</span>, <span class="number">400</span>), render, green, ybuffer);</span><br><span class="line"><span class="built_in">rasterize</span>(<span class="built_in">Vec2i</span>(<span class="number">330</span>, <span class="number">463</span>), <span class="built_in">Vec2i</span>(<span class="number">594</span>, <span class="number">200</span>), render, blue,  ybuffer);</span><br></pre></td></tr></table></figure><p>渲染的函数嘛。。。还是老样子，延x迭代，找到对应y坐标，如果比当前的y—buffer大，说明这个点更接近相机，绘制并更新y-buffer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rasterize</span><span class="params">(Vec2i p0, Vec2i p1, TGAImage &amp;image, TGAColor color, <span class="type">int</span> ybuffer[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p0.x&gt;p1.x)&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(p0,p1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=p0.x;x&lt;p1.x;x++)&#123;</span><br><span class="line">        <span class="type">float</span> t=(x-p0.x)/(<span class="type">float</span>)(p1.x-p0.x);</span><br><span class="line">        <span class="type">int</span> y=p0.y*(<span class="number">1.</span>-t)+p1.y*t;</span><br><span class="line">        <span class="keyword">if</span>(ybuffer[x]&lt;y)</span><br><span class="line">        &#123;</span><br><span class="line">            ybuffer[x]=y;</span><br><span class="line">            image.<span class="built_in">set</span>(x,<span class="number">0</span>,color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是时候把这一原理带回到3D了<br>为了绘制在平面上，我们需要使用一个二维数组。。。才不要呢<br>我们可以把二维的缓冲区打包成一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *zbuffer=<span class="keyword">new</span> <span class="type">int</span>[width*height];</span><br><span class="line"><span class="type">int</span> idx=x+y*width;</span><br><span class="line"><span class="comment">//这样转换后不同的点唯一对应一个idx，并且非常好转换</span></span><br><span class="line"><span class="type">int</span> x=idx % width;</span><br><span class="line"><span class="type">int</span> y=idx / width;</span><br></pre></td></tr></table></figure><p>下一步，如何确定z值？<br>回顾一下y-buffer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y=p0.y*(<span class="number">1.</span>-t)+p1.y*t;</span><br><span class="line"><span class="comment">//即采用重心坐标</span></span><br><span class="line"><span class="type">int</span> z=<span class="built_in">sigma</span>(pts[i][<span class="number">2</span>]*bc_screen[i]);<span class="comment">//重心坐标计算见上节</span></span><br></pre></td></tr></table></figure><p>最后的函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec3f *pts, <span class="type">float</span> *zbuffer, TGAImage &amp;image, TGAColor color)</span> </span>&#123;</span><br><span class="line">    <span class="function">Vec2f <span class="title">bboxmin</span><span class="params">( std::numeric_limits&lt;<span class="type">float</span>&gt;::max(),  std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="function">Vec2f <span class="title">bboxmax</span><span class="params">(-std::numeric_limits&lt;<span class="type">float</span>&gt;::max(), -std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line">    <span class="function">Vec2f <span class="title">clamp</span><span class="params">(image.get_width()<span class="number">-1</span>, image.get_height()<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++) &#123;</span><br><span class="line">            bboxmin[j] = std::<span class="built_in">max</span>(<span class="number">0.f</span>,      std::<span class="built_in">min</span>(bboxmin[j], pts[i][j]));</span><br><span class="line">            bboxmax[j] = std::<span class="built_in">min</span>(clamp[j], std::<span class="built_in">max</span>(bboxmax[j], pts[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Vec3f P;</span><br><span class="line">    <span class="keyword">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class="line">            Vec3f bc_screen  = <span class="built_in">barycentric</span>(pts[<span class="number">0</span>], pts[<span class="number">1</span>], pts[<span class="number">2</span>], P);</span><br><span class="line">            <span class="keyword">if</span> (bc_screen.x&lt;<span class="number">0</span> || bc_screen.y&lt;<span class="number">0</span> || bc_screen.z&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            P.z = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) P.z += pts[i][<span class="number">2</span>]*bc_screen[i];</span><br><span class="line">            <span class="keyword">if</span> (zbuffer[<span class="built_in">int</span>(P.x+P.y*width)]&lt;P.z) &#123;</span><br><span class="line">                zbuffer[<span class="built_in">int</span>(P.x+P.y*width)] = P.z;</span><br><span class="line">                image.<span class="built_in">set</span>(P.x, P.y, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>注意函数传入的三角形顶点为三维坐标(x,y,z);</li><li>计算包围盒时实际还是计算的平面包围盒，即只根据(x,y)确定；</li><li>遍历平面包围盒，确定点是否在三角形内，计算P.z，判定zbuffer和P.z的大小，原理同上面的ybuffer；</li></ol><h2 id="透视投影和简单变换"><a href="#透视投影和简单变换" class="headerlink" title="透视投影和简单变换"></a>透视投影和简单变换</h2><p>看过games101的话这里应该毫无压力</p><h3 id="2D平面"><a href="#2D平面" class="headerlink" title="2D平面"></a>2D平面</h3><p>一个点(x,y)的变换可以写成这种形式<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>a&amp;b\<br>c&amp;d<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>x\<br>y<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>ax+by\<br>cx+dy\end{array}\right)<br>\end{equation}<br>$$</p><p>本身的变换(不移动任何点),乘以I即可<br>缩放矩阵为：<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>a&amp;0\<br>0&amp;b<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>x\<br>y<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>ax\<br>by\end{array}\right)<br>\end{equation}<br>$$<br>用矩阵的好处在于，我们可以在一连串的变换中，一起进行变换，比如<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>3&#x2F;2&amp;0\<br>0&amp;3&#x2F;2<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>-1&amp;1&amp;1&amp;0&amp;-1\<br>-1&amp;-1&amp;0&amp;1&amp;1<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>-3&#x2F;2&amp;3&#x2F;2&amp;3&#x2F;2&amp;0&amp;-3&#x2F;2\<br>-3&#x2F;2&amp;-3&#x2F;2&amp;0&amp;3&#x2F;2&amp;3&#x2F;2<br>\end{array}\right)<br>\end{equation}<br>$$<br>另一个重要变换：错切<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>1&amp;a\<br>0&amp;1<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>x\<br>y<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>x+ay\<br>y\end{array}\right)<br>\end{equation}<br>$$<br>这是一个沿x轴的错切，(纵坐标不变，横坐标拉伸或收缩)<br>缩放和错切是平面上的基础线性变换，那旋转？<br>事实证明，任何旋转(绕原点旋转)都可以表示为三个错切的组合动作<br>但是太复杂了，我们需要一个旋转矩阵<br>饶原点逆时针旋转：<br>$$<br>\begin{pmatrix}<br>   cosA &amp; -sinA \<br>   sinA &amp; cosA<br>\end{pmatrix}<br>$$<br>所以，平面上的线性变换都是由缩放和错切组成的，我们可以用上面的矩阵表示它们，还有谁？平移，好吧，平移不是线性的，平移是仿射变换，<br>当然，我们大可以在线性变换后加上平移<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>a&amp;b\<br>c&amp;d<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>x\<br>y<br>\end{array}\right)<br>+<br>\left(\begin{array}{cccc}<br>e\<br>f\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>ax+by+e\<br>cx+dy+f\end{array}\right)<br>\end{equation}<br>$$<br>可是当我们想组成多个变换的时候，我们需要不停的乘，加，乘，加……<br>所以还是想办法组成一个矩阵吧</p><h3 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h3><p>我们将变换矩阵变为3X3：<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>a&amp;b&amp;e\<br>c&amp;d&amp;f\<br>0&amp;0&amp;1<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>x\<br>y\<br>1<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>ax+by+e\<br>cx+dy+f\<br>1<br>\end{array}\right)<br>\end{equation}<br>$$<br>很神奇，我们得到的向量的前面两个分量和刚才的计算结果相同<br>实际上，齐次坐标是将2D变换在3D中进行，然后进行投影<br>在齐次坐标中，对于一个(x,y,z)当z不为0时这是一个点，当z&#x3D;1时这个点的x，y即为其在2D空间的坐标，当z&#x3D;0时这是一个向量<br>这不是巧合，这是一个必然的结果：<br>向量+向量&#x3D;向量；<br>向量-向量&#x3D;向量；<br>点-点等于向量；<br>点+向量&#x3D;向量。(看z的变化)<br>点+点嘛，你也没听说过这个概念，是否可以理解为中点的简单求法(个人猜测)<br>接下来，我们可以自由的变换了，比如绕某个点旋转？<br>我们只需要先平移(把旋转点平移到原点)，在旋转，在平移回来就完成了<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>1&amp;0&amp;x_{0}\<br>0&amp;1&amp;y_{0}\<br>0&amp;0&amp;1<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>cos(a)&amp;-sin(a)&amp;0\<br>sin(a)&amp;cos(a)&amp;0\<br>0&amp;0&amp;1<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>1&amp;0&amp;-x_{0}\<br>0&amp;1&amp;-y_{0}\<br>0&amp;0&amp;1<br>\end{array}\right)<br>\end{equation}<br>$$<br>注意矩阵运算的顺序<br>后面矩阵的是先做的变换</p><p>现在注意矩阵的下面，矩阵的下面有什么用呢？<br>比如：<br>$$<br>\begin{pmatrix}<br>   1 &amp; 0&amp;0 \<br>   0 &amp; 1&amp;0\<br>   -1&#x2F;5&amp;0&amp;1<br>\end{pmatrix}<br>$$<br>我们发现，所有的垂直段还是垂直段，靠近摄像头的部分会被拉伸，远离摄像头的部分会被缩小，如果我们正确选择系数，我们就会得到一个透视投影的图像</p><h3 id="回到三维"><a href="#回到三维" class="headerlink" title="回到三维"></a>回到三维</h3><p>当摄像机在z轴上一点(0,0,c)时，由简单的相似变换，我们就可以将一个点(x,y,z)投影到x，y平面上<br>也就是x’&#x3D;x&#x2F;(1-z&#x2F;c);y’&#x3D;y&#x2F;(1-z&#x2F;c);<br>所以我们能得到这样一个矩阵<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>1&amp;0&amp;0&amp;0\<br>0&amp;1&amp;0&amp;0\<br>0&amp;0&amp;1&amp;0\<br>0&amp;0&amp;1&#x2F;c&amp;0<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>x\<br>y\<br>z\<br>1<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>x\<br>y\<br>z\<br>1-z&#x2F;c<br>\end{array}\right)<br>\end{equation}<br>$$<br>去掉z，就是我们需要的坐标(如果要用到z-buffer，你还是需要它)</p><h2 id="移动摄像机"><a href="#移动摄像机" class="headerlink" title="移动摄像机"></a>移动摄像机</h2><p>在欧几里得空间中，一个点的坐标有给定坐标系表示，如果想要把点的坐标从一个坐标系转换到另一个坐标系，只需要一个非退化矩阵M<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>i’&amp;j’&amp;k’<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>i&amp;j&amp;k<br>\end{array}\right)<br>M<br>\end{equation}<br>$$<br>对于OP向量<br>我们可以写为：<br>$$<br>\begin{equation}<br>OP&#x3D;OO’+O’P&#x3D;<br>\left(\begin{array}{cccc}<br>i&amp;j&amp;k<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>O_{x}’\<br>O_{y}’\<br>O_{z}’<br>\end{array}\right)<br>+<br>\left(\begin{array}{cccc}<br>i’&amp;j’&amp;k’<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>x’\<br>y’\<br>z’<br>\end{array}\right)<br>\end{equation}<br>$$<br>公式表示的OP，也是P相对于O为原点的坐标系的坐标(x,y,z);<br>在O’为原点的坐标系中，O’P为坐标(x’,y’,z’);<br>这样，就将同一位置在两个坐标系中的坐标联系了起来<br>其中OP为<br>$$<br>\begin{equation}<br>OP&#x3D;ix+jy+kz&#x3D;<br>\left(\begin{array}{cccc}<br>i&amp;j&amp;k<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>x\<br>y\<br>z<br>\end{array}\right)<br>\end{equation}<br>$$<br>简单代换后得到<br>$$<br>\begin{equation}<br>OP&#x3D;<br>\left(\begin{array}{cccc}<br>i&amp;j&amp;k<br>\end{array}\right)<br>(<br>\left(\begin{array}{cccc}<br>O_{x}’\<br>O_{y}’\<br>O_{z}’<br>\end{array}\right)<br>+M<br>\left(\begin{array}{cccc}<br>x’\<br>y’\<br>z’<br>\end{array}\right)<br>)<br>\end{equation}<br>$$<br>最后就得到了两个坐标系的坐标转换公式（从O到O’）<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>x\<br>y\<br>z<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>O_{x}’\<br>O_{y}’\<br>O_{z}’<br>\end{array}\right)<br>+M<br>\left(\begin{array}{cccc}<br>x’\<br>y’\<br>z’<br>\end{array}\right)<br>&#x3D;&gt;<br>\left(\begin{array}{cccc}<br>x’\<br>y’\<br>z’<br>\end{array}\right)<br>&#x3D;M^-1^(<br>\left(\begin{array}{cccc}<br>x\<br>y\<br>z<br>\end{array}\right)<br>-<br>\left(\begin{array}{cccc}<br>O_{x}’\<br>O_{y}’\<br>O_{z}’<br>\end{array}\right)<br>)<br>\end{equation}<br>$$<br>我们的模型坐标在Oxyz坐标系中给出，但我们的摄像机不总是位于z轴并且对准原点(我们希望它这样)，向上的方向也不确定。所以我们需要“移动”摄像机，实际上是变换空间坐标，让空间新的坐标系来满足摄像机的位置。<br>当一个摄像机eye以up为向上的方向，看向目标center时，我们对空间坐标进行变化，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lookat</span><span class="params">(Vec3f eye,Vec3f center, Vec3f up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vec3f z=(eye-center).<span class="built_in">normalize</span>();<span class="comment">//摄像机看向的方向的反向，注意在新的坐标系中z的负方向才是摄像机看向的方向</span></span><br><span class="line">    Vec3f x=<span class="built_in">cross</span>(up,z).<span class="built_in">normalize</span>();</span><br><span class="line">    Vec3f y=<span class="built_in">cross</span>(z,x).<span class="built_in">normalize</span>();<span class="comment">//用叉乘求xy方向</span></span><br><span class="line">    Matrix Minv=Matrix::<span class="built_in">identity</span>(<span class="number">4</span>);</span><br><span class="line">    Matrix Tr=Matrix::<span class="built_in">identity</span>(<span class="number">4</span>);<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      Minv[<span class="number">0</span>][i]=x[i];</span><br><span class="line">      Minv[<span class="number">1</span>][i]=y[i];</span><br><span class="line">      Minv[<span class="number">2</span>][i]=z[i];</span><br><span class="line">      Tr[i][<span class="number">3</span>]=-center[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ModelView=Minv*Tr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tr容易理解，就是把观察的center移到原点，(注意仿射变换的顺序在线性变换之前)<br>主要解释一下Minv，其实它就是我们上面的M^-1^，首先想想M是干啥的，他把Oxyz变成了Ox’y’z’(upXz,zXx,-z),那么我们可以得到M的值<br>$$<br>\begin{pmatrix}<br>   x_{upXz} &amp; x_{zXx} &amp; x_{-z} \<br>   y_{upXz} &amp; y-{zXx} &amp; y_{-z} \<br>   z_{upXz} &amp; z-{zXx} &amp; z_{-z}<br>\end{pmatrix}<br>$$<br>正好，这是一个正交矩阵，我们求其逆矩阵实际就是其转置，即为Minv<br>至此，我们可以对任何一个点进行ModelView变换</p><h3 id="视口矩阵"><a href="#视口矩阵" class="headerlink" title="视口矩阵"></a>视口矩阵</h3><p>参考games101<br>实际上就是把[-1,1]^2^这个空间中的已经变换好的图像变换到我们的屏幕中[0,width][0,height]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">viewport</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    Matrix m = Matrix::<span class="built_in">identity</span>(<span class="number">4</span>);</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">3</span>] = x+w/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">3</span>] = y+h/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">3</span>] = depth/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = w/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">1</span>] = h/<span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">2</span>] = depth/<span class="number">2.f</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体矩阵为<br>$$<br>\begin{pmatrix}<br>   $\frac w2$ &amp; 0 &amp; 0 &amp; x+$\frac w2$ \<br>   0 &amp; $\frac h2$ &amp; 0 &amp; y+$\frac h2$ \<br>   0 &amp; 0 &amp; $\frac d2$ &amp; $\frac d2$\<br>   0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$<br>注意d是用于z-缓冲区的深度计算</p><h3 id="连续空间坐标变换"><a href="#连续空间坐标变换" class="headerlink" title="连续空间坐标变换"></a>连续空间坐标变换</h3><p>对于.obj文件中的一个点v，我们要在屏幕上显示它，只需要经过<br>Viewport * Projection * View * Model * v;非常简单</p><h3 id="法向量变换"><a href="#法向量变换" class="headerlink" title="法向量变换"></a>法向量变换</h3><h2 id="顶点着色器和片元着色器"><a href="#顶点着色器和片元着色器" class="headerlink" title="顶点着色器和片元着色器"></a>顶点着色器和片元着色器</h2><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><ul><li>主要目标：转换顶点的坐标</li><li>次要目标：为片元着色器准备数据<h3 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h3></li><li>主要目标：确定当前像素的颜色。</li><li>次要目标–可以通过返回true来丢弃当前像素<h3 id="纹理和法线贴图"><a href="#纹理和法线贴图" class="headerlink" title="纹理和法线贴图"></a>纹理和法线贴图</h3>纹理中的RGB值可以储存不同的东西，比如该点的xyz坐标，因此我们可以用这个图像提供每个像素的法向量而不是仅仅为顶点提供<h3 id="镜面贴图"><a href="#镜面贴图" class="headerlink" title="镜面贴图"></a>镜面贴图</h3>最终的光照&#x3D;环境光照(一个常数，和场景有关)，漫反射(计算)，高光(镜面光照)</li><li>Phong Reflection &#x3D; Ambient + Diffuse + Specular</li></ul><h2 id="切线空间和法线映射"><a href="#切线空间和法线映射" class="headerlink" title="切线空间和法线映射"></a>切线空间和法线映射</h2><h3 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h3><h4 id="三角形的切线空间"><a href="#三角形的切线空间" class="headerlink" title="三角形的切线空间"></a>三角形的切线空间</h4><p>模型空间，世界空间，切线空间：<br>  抛开不相关的因素，减小问题的复杂度<br>纹理坐标定义于切线空间</p><ul><li>u：tangent轴(T)</li><li>v：bitangent轴(B)</li><li>n：法线轴(N)</li></ul><p>三角形的三个顶点坐标:V0,V1,V2<br>对应纹理坐标:(u0,v0),(u1,v1),(u2,v2).<br>定义三角形的两条边:E0&#x3D;V1-V0,E1&#x3D;V2-V0<br>对应纹理坐标差值:(t1,b1)&#x3D;(u1-u0,v1-v0),(t2,b2)&#x3D;(u2-u0,v2-v0)<br>有如下关系:E0 &#x3D;t1T + b1B  E1 &#x3D; t2T + b2B(T,B为对应坐标轴)<br>  实际为<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>E0\<br>E1<br>\end{array}\right)<br>&#x3D;<br>\left(\begin{array}{cccc}<br>t1&amp;b1\<br>t2&amp;b2<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>T\<br>B<br>\end{array}\right)<br>\end{equation}<br>$$<br>让变换矩阵为A，A可逆<br>所以得到切线空间TB轴为：<br>$$<br>\begin{equation}<br>\left(\begin{array}{cccc}<br>T\<br>B<br>\end{array}\right)<br>&#x3D;<br>1&#x2F;(t1b2-b1t2)<br>\left(\begin{array}{cccc}<br>b2&amp;-b1\<br>-t2&amp;t1<br>\end{array}\right)<br>\left(\begin{array}{cccc}<br>E0\<br>E1<br>\end{array}\right)<br>\end{equation}<br>$$<br>右边全是已知的，N是TB的叉积<br>3D模型文件中一般会提供顶点位置坐标，纹理坐标，法线等信息，但会缺少切线坐标系相关信息，所以求切线坐标是有必要的<br>注意这里的TB一般不是标准化的，和一般其他坐标系不一样，因为纹理坐标与位置坐标显然使用不同的度量单位。</p><h3 id="顶点的切线空间"><a href="#顶点的切线空间" class="headerlink" title="顶点的切线空间"></a>顶点的切线空间</h3><p>采用其所在的所有三角形所对应的切线空间向量的平均值<br>与三角形法线求取顶点法线的方法思路一样</p><h2 id="法线映射"><a href="#法线映射" class="headerlink" title="法线映射"></a>法线映射</h2><p>法线贴图：Normal Map<br>一张纹理图，每个像素存放的是法线，RGBA分别存放法向量的XYZ方向和A存放高度信息<br>我们需要这样的法线信息来计算光照等！<br>从[-1,1]到[0,255]令x为[-1,1]中的任意值，通过y&#x3D;(x+1)&#x2F;2*255进行变换<br>重点在于这个纹理图是基于切线空间，好处是可以用一张纹理来显示所有的动作。如果使用世界坐标的话，由于物体位置变化，每一帧都需要用一张新的纹理，这显然是不可能的<br>同时我们还可以将一些相同的纹理表现在一起，比如手臂的一只，但在世界空间里这样的一只手臂的纹理只能表示左或右</p><p>现在，我们有三角形三个顶点的坐标p，纹理坐标uv，法向量n，光栅器提供了中心坐标alpha，beta，gamma，由此我们可以得到中间任何一点p的这些信息</p><h2 id="阴影映射-Shadow-mapping"><a href="#阴影映射-Shadow-mapping" class="headerlink" title="阴影映射 Shadow mapping"></a>阴影映射 Shadow mapping</h2><h3 id="阴影贴图"><a href="#阴影贴图" class="headerlink" title="阴影贴图"></a>阴影贴图</h3><p>在三维计算机中加入阴影的过程<br>像素与以纹理形式保存的光照深度缓冲区或者深度图像比较，通过这种方式计算像素是否处于光源照射范围之内，从而生成阴影</p><h2 id="最终作业的几个问题"><a href="#最终作业的几个问题" class="headerlink" title="最终作业的几个问题"></a>最终作业的几个问题</h2><ul><li>按xyz坐标输入后发现错误<br>主要是几个问题</li></ul><ol><li>坐标系发生了变化，本来的xyz坐标系绕x轴旋转了<br>问题在于摄像机的位置问题，摄像机在1,1,3的位置，看下来后应该是沿着z轴。</li><li>算三角形的函数应该和输入三个点的顺序无关，可事实是必须要以某个顺序输入才能正确打印<br>问题在于判断P点是否在三角形里的函数 里的判断pst是不是三角形，这里用行列式计算，那么顺序当然是很重要的啦，其实顺时针就行。注意这里已经是对投影后的坐标进行计算了。</li><li>正确的着色，着色应该要基于世界坐标</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机图形学学习记录&quot;&gt;&lt;a href=&quot;#计算机图形学学习记录&quot; class=&quot;headerlink&quot; title=&quot;计算机图形学学习记录&quot;&gt;&lt;/a&gt;计算机图形学学习记录&lt;/h1&gt;&lt;h2 id=&quot;Bresenham画线算法&quot;&gt;&lt;a href=&quot;#Bresenham画线算法&quot; class=&quot;headerlink&quot; title=&quot;Bresenham画线算法&quot;&gt;&lt;/a&gt;Bresenham画线算法&lt;/h2&gt;&lt;p&gt;首先编写一个画线的简单算法：&lt;/p&gt;</summary>
    
    
    
    <category term="Homework,notes" scheme="http://apocalyptic0.github.io/categories/Homework-notes/"/>
    
    
    <category term="Game,Computer Graphics" scheme="http://apocalyptic0.github.io/tags/Game-Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记</title>
    <link href="http://apocalyptic0.github.io/2022/04/11/DataStructure/"/>
    <id>http://apocalyptic0.github.io/2022/04/11/DataStructure/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-06-07T08:37:54.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构学习笔记"><a href="#数据结构学习笔记" class="headerlink" title="数据结构学习笔记"></a>数据结构学习笔记</h1><h2 id="README"><a href="#README" class="headerlink" title="README"></a>README</h2><p>该篇用于记录本人学习数据结构的笔记<br>在建立时(2022&#x2F;4&#x2F;11)已完成了链表，栈，队列的学习<br>参考书籍：《数据结构》张珊靓，朱宗胜主编；成都：电子科技大学出版社<br>持续更新中~~~</p><span id="more"></span><p>本周(2022&#x2F;4&#x2F;11)有game组的第一次作业，更新会稍微推迟<br>贴张骚图<br><img src="https://i0.hdslb.com/bfs/article/cff3145e9917376c537f038b1bf3c831ac7bc9ed.png@942w_498h_progressive.webp" alt="骚图"></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构学习笔记&quot;&gt;&lt;a href=&quot;#数据结构学习笔记&quot; class=&quot;headerlink&quot; title=&quot;数据结构学习笔记&quot;&gt;&lt;/a&gt;数据结构学习笔记&lt;/h1&gt;&lt;h2 id=&quot;README&quot;&gt;&lt;a href=&quot;#README&quot; class=&quot;headerlink&quot; title=&quot;README&quot;&gt;&lt;/a&gt;README&lt;/h2&gt;&lt;p&gt;该篇用于记录本人学习数据结构的笔记&lt;br&gt;在建立时(2022&amp;#x2F;4&amp;#x2F;11)已完成了链表，栈，队列的学习&lt;br&gt;参考书籍：《数据结构》张珊靓，朱宗胜主编；成都：电子科技大学出版社&lt;br&gt;持续更新中~~~&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="http://apocalyptic0.github.io/categories/notes/"/>
    
    
    <category term="dataStructure,C++" scheme="http://apocalyptic0.github.io/tags/dataStructure-C/"/>
    
  </entry>
  
  <entry>
    <title>GOAP学习笔记</title>
    <link href="http://apocalyptic0.github.io/2022/04/10/GOAP/"/>
    <id>http://apocalyptic0.github.io/2022/04/10/GOAP/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-06-07T08:37:54.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GOAP学习笔记"><a href="#GOAP学习笔记" class="headerlink" title="GOAP学习笔记"></a>GOAP学习笔记</h1><h2 id="README"><a href="#README" class="headerlink" title="README"></a>README</h2><p>从今天（2022.4.10）开始往后的一周，我将完成这部分内容以作为联创game组的第一次作业<br>第二次更新时间：2022&#x2F;4&#x2F;11&#x2F;21:10<br>第三次更新时间：2022&#x2F;4&#x2F;15&#x2F;22:35<br>更新完毕</p><span id="more"></span><p><u>这里是<a href="https://learn.unity.com/project/goal-driven-behaviour?uv=2019.4">参考视频</a></u></p><h1 id="GOAP简介"><a href="#GOAP简介" class="headerlink" title="GOAP简介"></a>GOAP简介</h1><h2 id="Goal-Oriented-Action-Planning"><a href="#Goal-Oriented-Action-Planning" class="headerlink" title="Goal Oriented Action Planning"></a>Goal Oriented Action Planning</h2><ul><li>一种AI技术</li><li>由Jeff Orkin于2000年代初设计</li><li>应用于游戏领域来控制NPC的行为</li><li><a href="http://alumni.media.mit.edu/~jorkin/goap.html">点击以获取更多相关内容</a><h3 id="FSM"><a href="#FSM" class="headerlink" title="FSM"></a>FSM</h3></li><li>GOAP具有FSM的所有要素，但他们的实现方式非常不同</li><li>都是用graph实现，但在GOAP中行为和目标是分开的</li><li>在GOAP中所有链接都将被删除</li><li>当一个目标被提出时，基于代理和世界的状态从所有可用任务中选择适当的行动方案<h3 id="Precondition-and-Effect"><a href="#Precondition-and-Effect" class="headerlink" title="Precondition and Effect"></a>Precondition and Effect</h3></li><li>GOAP中的每一个动作都有一个前提条件和一个效果</li><li>前提条件是动作开始前必须满足的状态</li><li>效果是动作发生后该对象的状态的改变</li><li>precondition和effect想匹配得到action chains</li></ul><p><img src="/2022/04/10/GOAP/graph/example.png" alt="example"></p><blockquote><p>在本例中，目标为hungry&#x3D;false</p><blockquote><p>一个代理不会进行任何行动直到给一个目标<br><em>目标是一个代理的最终状态</em>(而不是开始)*</p></blockquote></blockquote><blockquote><p>加入条件：有原料为真，有电话号码为真<br>从目标返回，通过chain看是否能实现<br>如果不能在最后找到匹配的状态，就放弃这个plan</p></blockquote><blockquote><p>分别从时间和空间考虑这个example的两个plan</p></blockquote><h2 id="conceptualization"><a href="#conceptualization" class="headerlink" title="conceptualization"></a>conceptualization</h2><ul><li><font color="red"><u>with actions goals and world states being fed into a planner</u></font></li><li><font color="green">the planner chains the actions together according to the goals and starting states,to determine which plans are achievable.</font></li></ul><h1 id="搭建GOAP环境"><a href="#搭建GOAP环境" class="headerlink" title="搭建GOAP环境"></a>搭建GOAP环境</h1><blockquote><p>很轻松的部分，跟着视频来就行<br>主要提两点</p><blockquote><p>各个区域(area)实际是去掉渲染器和碰撞器的立方体<br><a href="https://connect-cdn-public-prd.unitychina.cn/h1/20210302/1817c217-51d5-4549-b939-0f33ac56d4ec/GOAP_HospitalStarter.zip">相关资源</a></p></blockquote></blockquote><h1 id="对象处理的预计划"><a href="#对象处理的预计划" class="headerlink" title="对象处理的预计划"></a>对象处理的预计划</h1><p>同样简单的部分，分析了两个对象：病人和护士的动作</p><ul><li><font color="pink">最好在纸面上开始你的计划，debug的过程非常艰难</font><blockquote><p>对象</p><blockquote><p>目标<br>动作<br>环境和世界以及其他对象的影响</p></blockquote></blockquote></li></ul><hr><blockquote><p>病人</p><blockquote><p>去医院-&gt;登记-&gt;等待护士<br>被治疗<br>回家</p></blockquote></blockquote><blockquote><p>护士</p><blockquote><p>找到病人-&gt;带入诊室<br>休息(太过劳累时直接触发)</p></blockquote></blockquote><hr><ul><li>对象的状态和行为</li><li>需要被实现的目标</li><li>可进行的动作</li><li><em><strong>产生计划plan</strong></em></li></ul><h1 id="世界状态类"><a href="#世界状态类" class="headerlink" title="世界状态类"></a>世界状态类</h1><ul><li>用字典存储世界状态</li><li>完成了基本世界和世界状态的编写</li><li>就是字典的一些基本函数，较为简单<blockquote><p>新学习到的：</p><blockquote><p>使字典在unity上序列化表示<br>只读字段<br>需要复习的<br>unity中的Dictionary相关知识<br>set和get</p></blockquote></blockquote><h1 id="动作类"><a href="#动作类" class="headerlink" title="动作类"></a>动作类</h1></li><li>awaken()函数：在游戏对象生成时调用NavMeshAgent组件，写入字典</li><li>IsAchevableGiven函数通过遍历字典preconditions，查询是否于此时的状态（上一个动作的effect）符合，函数如下：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsAchievableGiven</span>(<span class="params">Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; conditions</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt;p <span class="keyword">in</span> preconditions)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!conditions.ContainsKey(p.Key))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>新学到的：<br>抽象类！</p><blockquote><p>abstract 不可以和static、virtual、final、native一起使用<br>声明为 abstract 成员可以不包括实现代码，但只要类中还有未实现的抽象成员(抽象方法)，那么这个类就是一个抽象类，抽象类的对象不能被实例化，通常作为被强制继承类必须实现某一成员，抽象类必须要有派生子类。并且，如果子类没有实现抽象类的所有方法，则子类也成为一个抽象类。<br>abstract方法只有方法头的声明，而用一个分号来代替方法体的定义；至于方法体的具体实现，那是由当前类的不同子类在他们各自的类定义中完成的。</p></blockquote></blockquote><h1 id="Agent类"><a href="#Agent类" class="headerlink" title="Agent类"></a>Agent类</h1></li><li>system.Linq，万能的查询语句，对数组，List，Dictionary进行高效操作(似乎有点像数据库的语法?)<a href="https://blog.csdn.net/qq_39108767/article/details/86648448">参考链接</a></li><li>子目标类(SubGoal)中包含：查询该目标的字典，remove用于判断目标执行后是否仍保留。比如病人看病的目标在痊愈后就取消了，但护士休息的目标在执行后仍会保留</li><li>Start函数中读取该对象的所有GAction类并存放在List中</li><li>LateUpdate函数在Update后执行</li></ul><hr><ul><li>GPlanner部分会比较困难<br>2022&#x2F;4&#x2F;12&#x2F;22:46 累了，傻逼英语小组作业</li></ul><h1 id="Gplanner类"><a href="#Gplanner类" class="headerlink" title="Gplanner类"></a>Gplanner类</h1><ol><li>定义了节点Node类，包括父节点，目前花费，状态和动作</li><li>plan函数</li></ol><ul><li><p>List用于存储所有可执行的动作</p></li><li><p>找到花费最少的路径，存储在result中</p></li><li><p>最后写入queue，返回</p></li><li><p>BuildGraph函数进行递归，为每一个可以执行的行动产生的结果建立一个新节点，若找到(GoalAchieved)在leave中加入该节点，若没找到，则进行递归，以新节点为父节点继续寻找</p></li><li><p>GoalAchieved函数，遍历所有goal的条件，若所有条件都在现在的状态中，则达成目标</p></li><li><p>ActionSubset函数，把除了当前已执行的动作以外的所有动作写入subset，继续参与递归</p></li><li><p>补一下忘了的insert函数，在把元素插入第i个元素之前，其余以此向后移动，本例中以此在n前插入其父节点，以便于存入队列中</p></li></ul><hr><p>好厉害的AI寻路，看到结果的一刻真的被震撼到，已经等不及要深入学习了，但是现在已经很晚了诶<br>2022&#x2F;4&#x2F;13&#x2F;23:27晚安！</p><h1 id="GAgent的LateUpdate函数"><a href="#GAgent的LateUpdate函数" class="headerlink" title="GAgent的LateUpdate函数"></a>GAgent的LateUpdate函数</h1><ul><li>如果当前可执行的动作已到达目标，即停止执行该动作</li><li>调入planner部分：按优先级搜索所有该对象的目标</li><li>对每一个子目标的每一步生成一个actionQueue，若找到路径，将该子目标设为当前子目标后退出循环</li><li>下一部分是在执行完某一动作后，若该动作需要在执行后移除(remove)则将其移除；清空planner</li><li>下一部分是执行动作部分，先将当前将要执行的步移出队列放入当前动作，随后寻找目标，调用AI寻路</li><li>两个抽象函数都是用于控制动作是否进行，在有需要时调用。PrePerform控制动作开始，PostPerform控制动作结束</li><li>关于如何从一个动作切换到另一个动作</li></ul><ol><li>在一个动作正在执行时，即currentAction!&#x3D;null&amp;&amp;currentAction.runing进入下面部分：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(currentAction!=<span class="literal">null</span>&amp;&amp;currentAction.running)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(currentAction.agent.hasPath&amp;&amp;currentAction.agent.remainingDistance&lt;<span class="number">1f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!invoked)</span><br><span class="line">                &#123;</span><br><span class="line">                    Invoke(<span class="string">&quot;CompleteAction&quot;</span>, currentAction.duration);</span><br><span class="line">                    invoked = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure></li><li>在这里面，如果还未到达终点，则直接return</li><li>若到达终点，在规定的秒数后调用CompleteAction完成动作，将running设为false，下一次执行时，不会进入该if，转而寻找执行下一个动作</li></ol><p><strong>其实有代码还是很好理解的，不过构建整个过程真的很了不起</strong></p><hr><p>接下来，在unity面板中链接每个对象的各个动作就行，非常简单</p><h1 id="一些显示UI"><a href="#一些显示UI" class="headerlink" title="一些显示UI"></a>一些显示UI</h1><ul><li><p>GAgentEditor<br><a href="https://blog.csdn.net/jfy307596479/article/details/84972848">Editor</a></p><pre><code> unity editor是一个通用的编辑器，提供了unity内部对象的创建，预览，编辑的功能及可视化界面。​ 用于扩展editor的类需要放到名字为“Editor&quot;的文件夹中，这个文件夹可以直接放到”Assets“文件夹下，也可以是项目目录任何文件夹下的子文件夹，比如”Assets/BigWorld/Editor&quot;。</code></pre></li></ul><p>————————————————</p><ul><li>Text<br>先来看看Instance吧，我都快忘记它了<br>第一个要看的是：属性：<br>set：在每次设置属性时执行，将某个变量设置为该值<br>get：在每次读取时执行，返回一个同类型变量<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单示例</span></span><br><span class="line"><span class="keyword">public</span> Vector3 pos&#123;</span><br><span class="line">    <span class="keyword">get</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.transform.position);</span><br><span class="line">    &#125;<span class="comment">//get中return是必须的，读取时返回transform.position</span></span><br><span class="line">    <span class="keyword">set</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.position=<span class="keyword">value</span>;</span><br><span class="line">    &#125;<span class="comment">//设置该属性是同时变动transform.position</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>instance是只读的对象，GWorld类调用Getworld返回world，WorldState类调用GetStates返回states，然后在text中将其输出</li></ul><h1 id="GInventory类"><a href="#GInventory类" class="headerlink" title="GInventory类"></a>GInventory类</h1><p>三个方法：</p><ol><li>添加item</li><li>通过tag寻找item</li><li>移出item<br>非常简单</li></ol><h1 id="各个对象的行为："><a href="#各个对象的行为：" class="headerlink" title="各个对象的行为："></a>各个对象的行为：</h1><ul><li><em><strong>病人</strong></em><br>goal 1:isWaiting 优先级：3<br>action：<br>null -&gt; go to hospital -&gt; has arrived<br>has arrived -&gt; register -&gt; has registered<br>has registered -&gt; go to waiting room -&gt; isWaiting(在这时加入世界的病人队列并且加入Waiting和atHospital世界状态)</li></ul><p>goal 2:isTreated 优先级：5<br>action:<br>atHospital -&gt; GetTreated -&gt; is Treated</p><ul><li><p><em><strong>护士</strong></em><br>goal:treatPatient 优先级：3<br>Waiting&amp;&amp;free cubicle(注意他们是start节点里的世界状态) -&gt; get patient(调用remove将patient移出队列) -&gt; patientPickedup(同时将空闲的cubicle写入该patient的item，使其可以被GetTreated中的启动函数查找到，这解释了为什么要护士完成该步后病人才能开始第二轮移动)<br>patientPickedup -&gt; GoToCubicle -&gt;treatPatient</p></li><li><p><em><strong>cubicle小隔间</strong></em><br>和patient的方法类似<br>在世界开始时通过tag寻找并填入队列</p></li><li><p>在GAgent中加入了beliefs（WorldStates）变量调用当前对象状态<br>三种不同的WorldStates：</p></li></ul><ol><li>世界状态，显示在Text中</li><li>对象状态，存储在beliefs中</li><li>动作产生的effect，直接由currentstate记录</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GOAP学习笔记&quot;&gt;&lt;a href=&quot;#GOAP学习笔记&quot; class=&quot;headerlink&quot; title=&quot;GOAP学习笔记&quot;&gt;&lt;/a&gt;GOAP学习笔记&lt;/h1&gt;
&lt;h2 id=&quot;README&quot;&gt;&lt;a href=&quot;#README&quot; class=&quot;headerlink&quot; title=&quot;README&quot;&gt;&lt;/a&gt;README&lt;/h2&gt;&lt;p&gt;从今天（2022.4.10）开始往后的一周，我将完成这部分内容以作为联创game组的第一次作业&lt;br&gt;第二次更新时间：2022&amp;#x2F;4&amp;#x2F;11&amp;#x2F;21:10&lt;br&gt;第三次更新时间：2022&amp;#x2F;4&amp;#x2F;15&amp;#x2F;22:35&lt;br&gt;更新完毕&lt;/p&gt;</summary>
    
    
    
    <category term="Homework,notes" scheme="http://apocalyptic0.github.io/categories/Homework-notes/"/>
    
    
    <category term="Game,AI" scheme="http://apocalyptic0.github.io/tags/Game-AI/"/>
    
  </entry>
  
</feed>
